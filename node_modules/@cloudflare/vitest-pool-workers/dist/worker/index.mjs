// src/worker/index.ts
import assert3 from "node:assert";
import { Buffer as Buffer3 } from "node:buffer";
import events from "node:events";
import process from "node:process";
import * as vm from "node:vm";
import defines from "__VITEST_POOL_WORKERS_DEFINES";
import {
  createWorkerEntrypointWrapper,
  internalEnv,
  maybeHandleRunRequest,
  registerHandlerAndGlobalWaitUntil,
  runInRunnerObject,
  setEnv
} from "cloudflare:test-internal";

// ../../node_modules/.pnpm/devalue@5.3.2/node_modules/devalue/src/utils.js
var DevalueError = class extends Error {
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key) {
  return is_identifier.test(key) ? "." + key : "[" + JSON.stringify(key) + "]";
}

// ../../node_modules/.pnpm/devalue@5.3.2/node_modules/devalue/src/base64.js
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    binaryString += String.fromCharCode(dv.getUint8(i));
  }
  return binaryToAscii(binaryString);
}
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i = 0; i < arraybuffer.byteLength; i++) {
    dv.setUint8(i, binaryString.charCodeAt(i));
  }
  return arraybuffer;
}
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i = 0; i < data.length; i++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
function binaryToAscii(str) {
  let out = "";
  for (let i = 0; i < str.length; i += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i) & 3) << 4;
    if (str.length > i + 1) {
      groupsOfSix[1] |= str.charCodeAt(i + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i + 1) & 15) << 2;
    }
    if (str.length > i + 2) {
      groupsOfSix[2] |= str.charCodeAt(i + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}

// ../../node_modules/.pnpm/devalue@5.3.2/node_modules/devalue/src/constants.js
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;

// ../../node_modules/.pnpm/devalue@5.3.2/node_modules/devalue/src/parse.js
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index, standalone = false) {
    if (index === UNDEFINED) return void 0;
    if (index === NAN) return NaN;
    if (index === POSITIVE_INFINITY) return Infinity;
    if (index === NEGATIVE_INFINITY) return -Infinity;
    if (index === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index in hydrated) return hydrated[index];
    const value = values[index];
    if (!value || typeof value !== "object") {
      hydrated[index] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          return hydrated[index] = reviver(hydrate(value[1]));
        }
        switch (type) {
          case "Date":
            hydrated[index] = new Date(value[1]);
            break;
          case "Set":
            const set = /* @__PURE__ */ new Set();
            hydrated[index] = set;
            for (let i = 1; i < value.length; i += 1) {
              set.add(hydrate(value[i]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index] = map;
            for (let i = 1; i < value.length; i += 2) {
              map.set(hydrate(value[i]), hydrate(value[i + 1]));
            }
            break;
          case "RegExp":
            hydrated[index] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index] = obj;
            for (let i = 1; i < value.length; i += 2) {
              obj[value[i]] = hydrate(value[i + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate(value[1]));
            hydrated[index] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array = new Array(value.length);
        hydrated[index] = array;
        for (let i = 0; i < value.length; i += 1) {
          const n = value[i];
          if (n === HOLE) continue;
          array[i] = hydrate(n);
        }
      }
    } else {
      const object = {};
      hydrated[index] = object;
      for (const key in value) {
        if (key === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n = value[key];
        object[key] = hydrate(n);
      }
    }
    return hydrated[index];
  }
  return hydrate(0);
}

// ../../node_modules/.pnpm/devalue@5.3.2/node_modules/devalue/src/stringify.js
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom = [];
  if (reducers) {
    for (const key of Object.getOwnPropertyNames(reducers)) {
      custom.push({ key, fn: reducers[key] });
    }
  }
  const keys = [];
  let p = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index2 = p++;
    indexes.set(thing, index2);
    for (const { key, fn } of custom) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index2] = `["${key}",${flatten(value2)}]`;
        return index2;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i = 0; i < thing.length; i += 1) {
            if (i > 0) str += ",";
            if (i in thing) {
              keys.push(`[${i}]`);
              str += flatten(thing[i]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key) ? stringify_primitive(key) : "..."})`
            );
            str += `,${flatten(key)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a = thing.byteOffset;
          const b = a + thing.byteLength;
          if (a > 0 || b !== typedArray.buffer.byteLength) {
            const m = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a / m},${b / m}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key in thing) {
              keys.push(stringify_key(key));
              str += `,${stringify_string(key)},${flatten(thing[key])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key));
              str += `${stringify_string(key)}:${flatten(thing[key])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index2] = str;
    return index2;
  }
  const index = flatten(value);
  if (index < 0) return `${index}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}

// ../miniflare/src/workers/core/devalue.ts
import assert from "node:assert";
import { Buffer } from "node:buffer";
var ALLOWED_ARRAY_BUFFER_VIEW_CONSTRUCTORS = [
  DataView,
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  BigInt64Array,
  BigUint64Array
];
var ALLOWED_ERROR_CONSTRUCTORS = [
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  Error
  // `Error` last so more specific error subclasses preferred
];
var structuredSerializableReducers = {
  ArrayBuffer(value) {
    if (value instanceof ArrayBuffer) {
      return [Buffer.from(value).toString("base64")];
    }
  },
  ArrayBufferView(value) {
    if (ArrayBuffer.isView(value)) {
      return [
        value.constructor.name,
        value.buffer,
        value.byteOffset,
        value.byteLength
      ];
    }
  },
  RegExp(value) {
    if (value instanceof RegExp) {
      const { source, flags } = value;
      const encoded = Buffer.from(source).toString("base64");
      return flags ? ["RegExp", encoded, flags] : ["RegExp", encoded];
    }
  },
  Error(value) {
    for (const ctor of ALLOWED_ERROR_CONSTRUCTORS) {
      if (value instanceof ctor && value.name === ctor.name) {
        return [value.name, value.message, value.stack, value.cause];
      }
    }
    if (value instanceof Error) {
      return ["Error", value.message, value.stack, value.cause];
    }
  }
};
var structuredSerializableRevivers = {
  ArrayBuffer(value) {
    assert(Array.isArray(value));
    const [encoded] = value;
    assert(typeof encoded === "string");
    const view = Buffer.from(encoded, "base64");
    return view.buffer.slice(
      view.byteOffset,
      view.byteOffset + view.byteLength
    );
  },
  ArrayBufferView(value) {
    assert(Array.isArray(value));
    const [name, buffer, byteOffset, byteLength] = value;
    assert(typeof name === "string");
    assert(buffer instanceof ArrayBuffer);
    assert(typeof byteOffset === "number");
    assert(typeof byteLength === "number");
    const ctor = globalThis[name];
    assert(ALLOWED_ARRAY_BUFFER_VIEW_CONSTRUCTORS.includes(ctor));
    let length = byteLength;
    if ("BYTES_PER_ELEMENT" in ctor) length /= ctor.BYTES_PER_ELEMENT;
    return new ctor(buffer, byteOffset, length);
  },
  RegExp(value) {
    assert(Array.isArray(value));
    const [name, encoded, flags] = value;
    assert(typeof name === "string");
    assert(typeof encoded === "string");
    const source = Buffer.from(encoded, "base64").toString("utf-8");
    return new RegExp(source, flags);
  },
  Error(value) {
    assert(Array.isArray(value));
    const [name, message, stack, cause] = value;
    assert(typeof name === "string");
    assert(typeof message === "string");
    assert(stack === void 0 || typeof stack === "string");
    const ctor = globalThis[name];
    assert(ALLOWED_ERROR_CONSTRUCTORS.includes(ctor));
    const error = new ctor(message, { cause });
    error.stack = stack;
    return error;
  }
};

// src/shared/chunking-socket.ts
import assert2 from "node:assert";
import { Buffer as Buffer2 } from "node:buffer";
function createChunkingSocket(socket, maxChunkByteLength = 1048576) {
  const listeners = [];
  const decoder = new TextDecoder();
  let chunks;
  socket.on((message) => {
    if (typeof message === "string") {
      if (chunks !== void 0) {
        assert2.strictEqual(message, "", "Expected end-of-chunks");
        message = chunks + decoder.decode();
        chunks = void 0;
      }
      for (const listener of listeners) {
        listener(message);
      }
    } else {
      chunks ??= "";
      chunks += decoder.decode(message, { stream: true });
    }
  });
  return {
    post(value) {
      if (Buffer2.byteLength(value) > maxChunkByteLength) {
        const encoded = Buffer2.from(value);
        for (let i = 0; i < encoded.byteLength; i += maxChunkByteLength) {
          socket.post(encoded.subarray(i, i + maxChunkByteLength));
        }
        socket.post("");
      } else {
        socket.post(value);
      }
    },
    on(listener) {
      listeners.push(listener);
    }
  };
}

// src/worker/index.ts
export * from "__VITEST_POOL_WORKERS_USER_OBJECT";
function structuredSerializableStringify(value) {
  return stringify(value, structuredSerializableReducers);
}
function structuredSerializableParse(value) {
  return parse(value, structuredSerializableRevivers);
}
globalThis.Buffer = Buffer3;
globalThis.process = process;
process.argv = [];
var cwd;
process.cwd = () => {
  assert3(cwd !== void 0, "Expected cwd to be set");
  return cwd;
};
Object.setPrototypeOf(process, events.EventEmitter.prototype);
globalThis.__console = console;
function getCallerFileName(of) {
  const originalStackTraceLimit = Error.stackTraceLimit;
  const originalPrepareStackTrace = Error.prepareStackTrace;
  try {
    let fileName = null;
    Error.stackTraceLimit = 1;
    Error.prepareStackTrace = (_error, callSites) => {
      fileName = callSites[0]?.getFileName();
      return "";
    };
    const error = {};
    Error.captureStackTrace(error, of);
    void error.stack;
    return fileName;
  } finally {
    Error.stackTraceLimit = originalStackTraceLimit;
    Error.prepareStackTrace = originalPrepareStackTrace;
  }
}
var originalSetTimeout = globalThis.setTimeout;
var originalClearTimeout = globalThis.clearTimeout;
var timeoutPromiseResolves = /* @__PURE__ */ new Map();
var monkeypatchedSetTimeout = (...args) => {
  const [callback, delay, ...restArgs] = args;
  const callbackName = args[0]?.name ?? "";
  const callerFileName = getCallerFileName(monkeypatchedSetTimeout);
  const fromVitest = /\/node_modules\/(\.store\/)?vitest/.test(
    callerFileName ?? ""
  );
  if (!fromVitest || delay) {
    return originalSetTimeout.apply(globalThis, args);
  }
  if (callbackName === "NOOP") {
    return -0.5;
  }
  let promiseResolve;
  const promise = new Promise((resolve) => {
    promiseResolve = resolve;
  });
  assert3(promiseResolve !== void 0);
  registerHandlerAndGlobalWaitUntil(promise);
  const id = originalSetTimeout.call(globalThis, () => {
    promiseResolve?.();
    callback?.(...restArgs);
  });
  timeoutPromiseResolves.set(id, promiseResolve);
  return id;
};
globalThis.setTimeout = monkeypatchedSetTimeout;
globalThis.clearTimeout = (...args) => {
  const id = args[0];
  if (id === -0.5) {
    return;
  }
  const maybePromiseResolve = timeoutPromiseResolves.get(id);
  timeoutPromiseResolves.delete(id);
  maybePromiseResolve?.();
  return originalClearTimeout.apply(globalThis, args);
};
function isDifferentIOContextError(e) {
  return e instanceof Error && e.message.startsWith("Cannot perform I/O on behalf of a different");
}
var WebSocketMessagePort = class extends events.EventEmitter {
  constructor(socket) {
    super();
    this.socket = socket;
    this.#chunkingSocket = createChunkingSocket({
      post(message) {
        socket.send(message);
      },
      on(listener) {
        socket.addEventListener("message", (event) => {
          listener(event.data);
        });
      }
    });
    this.#chunkingSocket.on((message) => {
      const parsed = structuredSerializableParse(message);
      this.emit("message", parsed);
    });
    socket.accept();
  }
  #chunkingSocket;
  postMessage(data) {
    const stringified = structuredSerializableStringify(data);
    try {
      if (this.socket.readyState === WebSocket.READY_STATE_OPEN) {
        this.#chunkingSocket.post(stringified);
      }
    } catch (error) {
      if (isDifferentIOContextError(error)) {
        const promise = runInRunnerObject(internalEnv, () => {
          this.#chunkingSocket.post(stringified);
        }).catch((e) => {
          __console.error("Error sending to pool inside runner:", e, data);
        });
        registerHandlerAndGlobalWaitUntil(promise);
      } else {
        __console.error("Error sending to pool:", error, data);
      }
    }
  }
};
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
var patchedFunction = false;
function ensurePatchedFunction(unsafeEval) {
  if (patchedFunction) {
    return;
  }
  patchedFunction = true;
  globalThis.Function = new Proxy(globalThis.Function, {
    construct(_target, args, _newTarget) {
      const script = args.pop();
      return unsafeEval.newFunction(script, "anonymous", ...args);
    }
  });
}
function applyDefines() {
  for (const [key, value] of Object.entries(defines)) {
    const segments = key.split(".");
    let target = globalThis;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === segments.length - 1) {
        target[segment] = value;
      } else {
        target = target[segment] ??= {};
      }
    }
  }
}
var __VITEST_POOL_WORKERS_RUNNER_DURABLE_OBJECT__ = class {
  executor;
  constructor(_state, env) {
    vm._setUnsafeEval(env.__VITEST_POOL_WORKERS_UNSAFE_EVAL);
    ensurePatchedFunction(env.__VITEST_POOL_WORKERS_UNSAFE_EVAL);
    setEnv(env);
    applyDefines();
  }
  async handleVitestRunRequest(request) {
    assert3.strictEqual(request.headers.get("Upgrade"), "websocket");
    const { 0: poolSocket, 1: poolResponseSocket } = new WebSocketPair();
    const workerDataHeader = request.headers.get("MF-Vitest-Worker-Data");
    assert3(workerDataHeader !== null);
    const wd = structuredSerializableParse(workerDataHeader);
    assert3(typeof wd === "object" && wd !== null);
    assert3("filePath" in wd && typeof wd.filePath === "string");
    assert3("name" in wd && typeof wd.name === "string");
    assert3("data" in wd && typeof wd.data === "object" && wd.data !== null);
    assert3("cwd" in wd && typeof wd.cwd === "string");
    cwd = wd.cwd;
    const port = new WebSocketMessagePort(poolSocket);
    try {
      const module = await import(wd.filePath);
      const { VitestExecutor } = await import("vitest/execute");
      const originalResolveUrl = VitestExecutor.prototype.resolveUrl;
      const that = this;
      VitestExecutor.prototype.resolveUrl = function(...args) {
        that.executor = this;
        return originalResolveUrl.apply(this, args);
      };
      wd.data.port = port;
      module[wd.name](wd.data).then(() => {
        poolSocket.close(1e3, "Done");
      }).catch((e) => {
        port.postMessage({ vitestPoolWorkersError: e });
        const error = reduceError(e);
        __console.error("Error running worker:", error.stack);
        poolSocket.close(1011, "Internal Error");
      });
    } catch (e) {
      const error = reduceError(e);
      __console.error("Error initialising worker:", error.stack);
      return Response.json(error, {
        status: 500,
        headers: { "MF-Experimental-Error-Stack": "true" }
      });
    }
    return new Response(null, { status: 101, webSocket: poolResponseSocket });
  }
  async fetch(request) {
    const response = await maybeHandleRunRequest(request, this);
    if (response !== void 0) {
      return response;
    }
    return this.handleVitestRunRequest(request);
  }
};
var worker_default = createWorkerEntrypointWrapper("default");
export {
  __VITEST_POOL_WORKERS_RUNNER_DURABLE_OBJECT__,
  worker_default as default
};
//# sourceMappingURL=index.mjs.map
